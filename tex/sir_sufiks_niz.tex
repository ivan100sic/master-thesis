\sirsection{Sufiks niz}

Sufiks niz je struktura podataka koja omogu\' cava brzu tra\v zenje pojavljivanja stringa unutar stringa za koji se konstrui\v se sufiks niz, ta\v cnije, vremenska slo\v zenost pretrage je sublinearna funkcija du\v zine stringa unutar kojeg se vr\v si pretraga. Pored ovoga, pomo\' cu sufiks niza se mogu brzo vr\v siti pore\dj enja podstringova unutar samog stringa.

\sirsubsection{Definicija}
Sufiks niz za string $s$ je niz sortiranih nepraznih sufiksa tog stringa. Formalno,

\begin{dfn}
Sufiks niz za string $s$ du\v zine $|s| = n$ je niz $p$ koji se sastoji od $n$ razli\v citih celih brojeva iz skupa $\{0,\ldots,n-1\}$ takav da je niz sufiksa \v cije su po\v cetne pozicije $p_0, p_1, \ldots, p_{n-1}$ leksikografski rastu\' ci niz.
\end{dfn}

Za svaki string postoji jedinstven sufiks niz, zato \v sto je leksikografsko ure\dj enje totalno a ne postoje dva jednaka sufiksa. Primera radi, na\dj imo sufiks niz za string \texttt{banana}. Ozna\v cimo sa $u_i$ string $s_{[i,n)}$. Svi sufiksi ovog stringa su:

\begin{center}
\begin{tabular}{cl}
    $u_0$ & \texttt{banana} \\
    $u_1$ & \texttt{anana} \\
    $u_2$ & \texttt{nana} \\
    $u_3$ & \texttt{ana} \\
    $u_4$ & \texttt{na} \\
    $u_5$ & \texttt{a} \\
\end{tabular}
\end{center}

Sortiranjem dobijamo niz sufiksa:

\begin{center}
\begin{tabular}{cl}
    $u_5$ & \texttt{a} \\
    $u_3$ & \texttt{ana} \\
    $u_1$ & \texttt{anana} \\
    $u_0$ & \texttt{banana} \\
    $u_4$ & \texttt{na} \\
    $u_2$ & \texttt{nana} \\
\end{tabular}
\end{center}

Sortirani niz sufiksa je $u_5, u_3, u_1, u_0, u_4, u_2$, pa je sufiks niz $p = (5,3,1,0,4,2)$.

\sirsubsection{Konstrukcija}

Kao i kod mnogih algoritamskih problema, i za problem nala\v zenja sufiks niza postoje algoritmi razli\v citih vremenskih slo\v zenosti. Svi brzi algoritmi se oslanjaju na \v cinjenicu da se radi o me\dj usobno zavisnim stringovima, po\v sto su svi stringovi sufiksi jednog te istog stringa.

\sirsubsection{Algoritam slo\v zenosti $O(n^2 \log n)$}

Sufiks niz se mo\v ze konstruisati prostim sortiranjem svih sufiksa u vremenskoj slo\v zenosti $O(n^2 \log n)$, ukoliko je dostupan algoritam za sortiranje op\v ste namene koji radi u slo\v zenosti $O(n \log n)$. Primer takvog algoritam je \textit{mergesort}. Radi u\v stede memorijskog prostora sortira\' cemo samo niz celih brojeva $0,1,\ldots,n-1$, dok \' cemo kao funkciju za pore\dj enje koristiti funkciju koja je "svesna" stringa $s$ i koja za data dva sufiksa odre\dj uje koji je manji. Vremenska slo\v zenost pore\dj enja dva sufiksa je $O(n)$, a kako \textit{mergesort} sortira niz sa $O(n \log n)$ poziva funkcije za pore\dj enje, ukupna vremenska slo\v zenost je $O(n^2 \log n)$.

Ozna\v cimo sa $k$ du\v zinu najdu\v zeg stringa koji se javlja vi\v se od jednom u stringu $s$. Nije te\v sko pokazati da, ako se pa\v zljivo implementira, funkcija pore\dj enja dva sufiksa radi u vremenskoj slo\v zenosti $O(k)$, pa se slo\v zenost konstrukcije sufiks niza mo\v ze i bolje proceniti sa $O(kn \log n)$. Kod pojedinih stringova, ovaj algoritam ima jako dobre performanse, u \v sta \' cemo se uveriti pore\dj enjem implementacija.

U dodatku \sirdodatak funkcija \texttt{sufiks\_niz\_n2logn} implementira glavni algoritam, dok klasa \texttt{uporedi\_sufikse} implementira pore\dj enje sufiksa i koristi se kao klju\v c za bibliote\v cku funkciju \texttt{sort}.

\sirsubsection{Algoritam slo\v zenosti $O(n \log^2 n)$}

Pre opisa samog algoritma defini\v semo cikli\v cni podstring i cikli\v cni pomeraj stringa.

\begin{dfn}
Cikli\v cni podstring stringa $s$ du\v zine $n$ po\v cev od pozicije $l$ do pozicije $r$ je string $s_{[l, r)} = s_{l \mod n}s_{(l+1)\mod n}\ldots s_{(r-1)\mod n}$.
\end{dfn}

Cikli\v cni podstring uop\v stava pojam podstringa. Zaista, ako je $0 \leq l \leq r \leq n$, cikli\v cni podstring jednak je obi\v cnom podstringu.

\begin{dfn}
Cikli\v cni pomeraj stringa $s$ du\v zine $n$ po\v cev od pozicije $i$ je string $s_{[i, i+n)}$.
\end{dfn}

Kod ovog algoritma sortiramo cikli\v cne podstringove. U daljem razmatranju njih \' cemo jednostavno zvati podstringovima. Prvo \' cemo pokazati kako se problem nala\v zenja sufiks niza svodi na sortiranje svih cikli\v cnih pomeraja stringa. Neka je $s \in \Sigma^+$. Pro\v sirimo alfabet $\Sigma$ dodavanjem novog simbola, koji \' cemo ozna\v citi sa $\$$ koji je po ure\dj enju manji od svih simbola iz $\Sigma$. Tada je $s' = s\$ \in (\Sigma \cup {\$})^+$. Neka je $n = |s|, n' = n+1 = |s'|$. Posmatrajmo sve cikli\v cne pomeraje stringa $s'$. Po\v sto se karakter $\$$ javlja samo jednom u stringu $s'$, svi ovi stringovi su razli\v citi pa postoji jedinstven leksikografski poredak. Leksikografski najmanji pomeraj bi\' ce $n'-1$, jer je taj pomeraj jedini koji po\v cinje karakterom $\$$ koji je po definiciji manji od svih ostalih.

\begin{thm}
Ako su $i,j$ proizvoljni pomeraji stringa $s'$ razli\v citi od $n'-1$, tada va\v zi $s_{[i, i+n')} < s_{[j, j+n')}$ akko je $s_{[i, n)} < s_{[j, n)}$. \hfill $\square$
\end{thm}

Odavde sledi da ako je niz $q_0, q_1, \ldots, q_n$ sortiran niz cikli\v cnih pomeraja stringa $s'$ tada je niz $p_i = q_{i+1}, i \in \{0, \ldots, n-1\}$ sufiks niz stringa $s$.

Kona\v cno, opi\v simo algoritam za sortiranje cikli\v cnih pomeraja stringa $s$ du\v zine $n$. Za svako $k \in \{0, 1, \ldots, \ceil{\log_2(n)} \}$ na\dj imo poredak svih cikli\v cnih podstringova du\v zine $2^k$. Ovaj poredak \' cemo opisati nizom celih brojeva $C^{(k)}$, gde stringu $s_{[i, i+2^k)}$ pridru\v zujemo broj $C^{(k)}_i$ na takav na\v cin da, ako su podstringovima $s_{[i, i+2^k)}$ i $s_{[j, j+2^k)}$ pridru\v zeni isti brojevi, tada su oni jednaki, a ako je jednom pridru\v zen manji broj, tada je taj podstring leksikografski manji. Za $k=0$, mo\v zemo jednostavno postaviti $C^{(0)}_i = \text{Ord}(s_i)$.

Neka je $k>0$. Na\v s cilj je da odredimo niz $C^{(k)}$ u vremenskoj slo\v zenosti $O(n \log n)$. Posmatrajmo podstringove $s_{[i, i+2^k)}$ i $s_{[j, j+2^k)}$ i posmatrajmo ure\dj ene parove $u_i = (C^{(k-1)}_i, C^{(k-1)}_{(i+2^{k-1}) \mod n })$ i $u_j = (C^{(k-1)}_j, C^{(k-1)}_{(j+2^{k-1}) \mod n })$. Tada je poredak ovih podstringova jednak poretku parova $u_i, u_j$. Ako za svaki cikli\v cni podstring odredimo ovaj ure\dj eni par, zatim sve dobijene parove sortiramo, a zatim ovim parovima dodelimo ordinalne vrednosti, dobi\' cemo upravo niz $C^{(k)}$. Ovo se mo\v ze jednostavno izvesti bilo kojim algoritmom za sortiranje koji radi u slo\v zenosti $O(n \log n)$.

Za kraj, neka je $k = \ceil{\log_2(n)}$. Odavde je $2^k \geq n$. U kontekstu konstrukcije sufiksnog niza, nijedna dva cikli\v cna pomeraja du\v zine $2^k$ ne\' ce biti jednaka, pa \' ce niz $C^{(k)}$ sadr\v zati razli\v cite brojeve. Odavde sortiran niz cikli\v cnih pomeraja mo\v zemo na\' ci kao inverznu permutaciju niza $C^{(k)}$. Va\v zno je napomenuti da \' ce poredak podstringova du\v zine $2^k$ biti jednak poretku podstringova du\v zine $n$, zato \v sto du\v zina najdu\v zeg zajedni\v ckog prefiksa za bilo koja dva razli\v cita podstringa (bilo koje du\v zine) iznosi $n-1$, upravo jer postoji karakter $\$$ koji se javlja samo jednom u stringu.

Kako ovaj algoritam ima $O(\log n)$ faza, a svaka faza radi u slo\v zenosti $O(n \log n)$, ukupna vremenska slo\v zenost je $O(n \log^2 n)$. Memorijska slo\v zenost je $O(n \log n)$, ali se mo\v ze smanjiti na $O(n)$ pam\' cenjem samo nizova $C^{(k)}$ prethodne i trenutne faze.

U dodatku \sirdodatak, \texttt{sortiraj\_ciklicne\_pomeraje\_nlog2n} je funkcija koja implementira ovaj algoritam za nala\v zenje redosleda cikli\v cnih pomeraja.

\sirsubsection{Algoritam slo\v zenosti $O(n \log n)$}

Prethodno opisani algoritam za nala\v zenje cikli\v cnih pomeraja je mogu\' ce modifikovati tako da radi u slo\v zenosti $O(n \log n)$. Naime, ukoliko bismo sortirali parove $u_i$ u linearnom vremenu, dobili bismo upravo tu vremensku slo\v zenost. Naime, svaki par se sastoji iz dva broja iz skupa $\{0, 1, \ldots, n-1\}$. Mo\v zemo primeniti ideju iz algoritma \textit{radix sort}. Naime, \textit{radix sort} se oslanja na \textit{counting sort}, koji ima jednostavnu implementaciju i mo\v ze da sortira bilo koji niz od $n$ elemenata \v ciji su klju\v cevi za pore\dj enje brojevi iz skupa $\{0, 1, \ldots, k-1\}$ u vremenskoj slo\v zenosti $O(n+k)$. Pritom, mogu\' ce je implementirati \textit{counting sort} kao stabilan algoritam sortiranja, odnosno algoritam koji ekvivalentnim elementima ne menja relativni poredak. Algoritam \textit{radix sort} za ure\dj ene parove bi prvo pomo\' cu \textit{counting sort}-a sortirao sve parove po drugom elementu, a zatim po prvim, vode\' ci ra\v cuna da se ne naru\v si prethodno ustanovljen poredak kori\v s\' cenjem stabilne varijante \textit{counting sort}-a.

Mogu\' ce je pojednostaviti prethodni algoritam, odnosno, svesti ga na samo jedno pozivanje \textit{counting sort}-a. Naime, pored nizova $C^{(k)}$ \v cuva\' cemo eksplicitno i permutaciju $p^{(k)}$ koja odgovara poretku podstringova du\v zine $2^k$. Posmatrajmo \v sta se de\v sava ukoliko pomo\' cu \textit{counting sort}-a sortiramo vrednosti $(j - 2^{k-1}) \mod n$, gde je klju\v c $C^{(k-1)}_{(j - 2^{k-1}) \mod n}$, uzete redom za svako $j$ iz niza $p^{(k-1)}$. Stabilan \textit{counting sort} \' ce urediti ove indekse $j' = (j - 2^{k-1}) \mod n$ po vrednosti $C^{(k-1)}_{j'}$, dok \' ce, ukoliko vi\v se njih ima istu vrednost, o\v cuvati prethodno ustanovljeni poredak. Kako je ovaj prethodni poredak indukovan vrednostima $C^{(k-1)}_j = C^{(k-1)}_{(j' + 2^{k-1}) \mod n}$, dobijamo upravo leksikografski redosled parova $(C^{(k-1)}_{j'}, C^{(k-1)}_{(j' + 2^{k-1}) \mod n})$. Sada na osnovu ovog sortiranog niz ra\v cunamo nove vrednosti $C^{(k)}$, dok je $p^{(k)}$ dobijen upravo pomenutim sortiranjem.

Kona\v cno re\v senje, odnosno sortiran niz cikli\v cnih pomeraja je upravo niz $p^{(k)}$ za $k = \ceil{\log_2(n)}$.

U dodatku \sirdodatak, \texttt{sortiraj\_ciklicne\_pomeraje\_nlogn} je funkcija koja implementira ovaj algoritam za nala\v zenje redosleda cikli\v cnih pomeraja. Funkcija koja nalazi sufiks niz je \texttt{sufiks\_niz\_brzi}. Ona kao parametar prima i funkciju koju \' ce zvati za sortiranje cikli\v cnih pomeraja stringa.

\sirsubsection{LCP niz}

Niz najdu\v zih zajedni\v ckih prefiksa (\textit{longest common prefix}) je niz koji se \v cesto zajedno koristi sa sufiks nizom. Za string $s$ du\v zine $n$, \v ciji je sufiks niz $p_0, p_1, \ldots, p_{n-1}$, LCP niz se sastoji od nenegativnih celih brojeva $q_0, q_1, \ldots, q_{n-2}$, gde $q_i$ ozna\v cava du\v zinu najdu\v zeg zajedni\v ckog prefiksa stringova $s_{[p_i, n)}$ i $s_{[p_{i+1}, n)}$.

Najdu\v zi zajedi\v cki prefiks zadovoljava jednu veoma va\v znu osobinu.

\begin{thm}
\label{lcposobina}
Neka je $s_1, s_2, s_n$ leksikografski sortiran niz stringova. Neka je $q_i = LCP(s_i, s_{i+1})$. Ako je $i<j$, tada je $LCP(s_i, s_j) = \min\{q_i, q_{i+1}, \ldots, q_{j-1}\}$. \hfill $\square$
\end{thm}

Kako se LCP niz konstrui\v se nad sortiranim nizom sufiksa jednog stringa, on se uz odgovaraju\' cu strukturu podataka za nala\v zenje minimuma u podnizu mo\v ze koristiti za odre\dj ivanje najdu\v zeg zajedni\v ckog prefiksa bilo koja dva sufiksa.

Pre nego \v sto opi\v semo algoritam za konstrukciju LCP niza, doka\v zimo slede\' cu teoremu.

\begin{thm}
\label{lcpalgoteorema}
Neka je $s$ string du\v zine $n$, \v ciji je sufiks niz $p_0, \ldots, p_{n-1}$, LCP niz $q_0, \ldots, q_{n-2}$. Defini\v semo $r = p^{-1}$ odnosno, $p_{r_i} = i$. Neka je $s_{[i, n)}$ njegov sufiks takav da je $i>0$ i $p_{n-1} \not = i, i-1$. Tada je $q_{r_i} \geq q_{r_{i-1}} - 1$.
\end{thm}

\textit{Dokaz:} Uvedimo oznake $i' = i-1$, $j = p_{r_i + 1}$, $j' = p_{r_{i'} + 1}$. Drugim re\v cima, sufiks $i'$ je onaj koji prethodi $i$, odnosno ima du\v zinu za $1$ ve\' cu. $j$ je sufiks koji se nalazi odmah posle $i$ u sufiks nizu. Sli\v cno, $j'$ je sufiks koji se nalazi odmah posle $i'$ u sufiks nizu.  Ukoliko je $q_{r_{i'}} \leq 1$, onda tvr\dj enje o\v cigledno va\v zi, jer je $q_{r_i} \geq 0$. Neka je $q_{r_{i'}} \geq 2$. Po\v sto je $j'$ posle $i'$ u sufiks nizu va\v zi $s_{[j', n)} > s_{[i', n)}$ a po\v sto je $q_{r_{i'}} \geq 1$ va\v zi $s_{i'} = s_{j'}$. Ako odbacimo prvi karakter sufiksa $i'$ i $j'$ ponovo dobijamo sufikse, $i'+1, j'+1$ i va\v zi $s_{[j'+1, n)} > s_{[i'+1, n)}$, odnosno $s_{[j'+1, n)} > s_{[i, n)}$ ili ekvivalentno $r_{j'+1} > r_i$. Du\v zina najdu\v zeg zajedni\v ckog prefiksa za $i'+1, j'+1$ je $q_{r_{i'}} - 1$. Na osnovu teoreme \ref{lcposobina} imamo da je $q_{r_{i'}} - 1 = LCP(s_{[i, n)}, s_{[j'+1, n)}) = \min\{ q_{r_i}, q_{r_i+1}, \ldots, q_{r_{j'+1}-1} \}$ odnosno $q_{r_{i'}} - 1 \leq q_{r_i}$ \hfill $\square$.

Algoritam za konstrukciju LCP niza radi na slede\' ci na\v cin. Kao ulaz se prosle\dj uju string i izra\v cunati sufiks niz tog stringa. Prvo se ra\v cuna inverz sufiksnog niza. Zatim se sufiksi obra\dj uju redom, opadaju\' ce po du\v zini, odnosno, uzimaju se redom sufiksi \v cije su po\v cetne pozicije $i = 0, 1, \ldots, n-1$ tim redom. U svakom trenutku odr\v zavamo promenljivu $k$ koja je manja ili jednaka od trenutne vrednosti $q_{r_i}$ koju tra\v zimo. U po\v cetku je $k=0$. Ukoliko je $r_i = n-1$, $q_{r_i}$ se i ne defini\v se i samo postavljamo $k=0$. U suprotnom, samo pove\' cavamo $k$ za po $1$ sve dok se odgovaraju\' ci karakteri sufiksa $i$ i $j = p_{r_i + 1}$ poklapaju. Kada do\dj emo do kraja nekog od ovih sufiksa ili se karakteri ne poklope, prekidamo, upisujemo $q_{r_i} := k$ i zatim, na osnovu teoreme \ref{lcpalgoteorema} smemo da postavimo $k := \max\{k-1, 0\}$.

Vremenska slo\v zenost ovog algoritma je $O(n)$ za ra\v cunanje inverza i petlju koja redom obra\dj uje sufikse, plus linearna po ukupnom broju uve\' cavanja promenljive $k$. Kako u ta\v cno jednoj iteraciji (kad je $r_i = n-1$) $k$ smanjujemo direktno na $0$, a u svim ostalim iteracijama $k$ smanjujemo za najvi\v se $1$, ukupno je smanjujemo za najvi\v se $2n-2$. Kako je po\v cetna vrednost $0$ a krajnja ne vi\v se od $n-1$, to zna\v ci da je $k$ pove\' cavamo najvi\v se $3n-3$, odnosno $O(n)$ puta, pa ceo algoritam radi u slo\v zenosti $O(n)$.

\sirsubsection{Primene}

\sirsubsubsection{Tra\v zenje jednog stringa u drugom}

Ukoliko je potrebno tra\v ziti veliki broj stringova, recimo njih $m$ unutar jednog istog stringa $s$ du\v zine $m$, pritom, za svaki od tih stringova je neophodno odmah na\' ci odgovor pre nego \v sto se po\v cne sa obradom slede\' ceg, bez preprocesiranja stringa $s$ bi\' ce nam potrebno bar $O(nm)$ vremena. Ukoliko su stringovi koji se tra\v ze mnogo manje du\v zine od $n$, recimo, svaki je du\v zine $d$, onda bi algoritam slo\v zenosti $O(md\log n)$ radio mnogo br\v ze.

Pomo\' cu sufiks niza realizacija algoritma koji tra\v zi string $t$ du\v zine $d$ u stringu $s$ je krajnje jednostavna. Binarnom pretragom po sufiks nizu tra\v zimo prvu poziciju takvu da je odgovaraju\' ci sufiks leksikografski ve\' ci ili jednak tra\v zenom stringu. Kako se pore\dj enje bilo kog sufiksa i stringa $p$ mo\v ze izvr\v siti u vremenu $O(d)$, slo\v zenost pretrage je $O(d \log n)$.

Funkcija \texttt{trazi} u Dodatku \sirdodatak implementira tra\v zenje ove pozicije u sufiks nizu. Uz minimalne izmene mogu\' ce je podr\v zati tra\v zenje opsega koji sadr\v zi sve sufikse \v ciji je prafiks string $p$, ukoliko postoji.

\sirsubsubsection{Najmanji cikli\v cni pomeraj}

Na osnovu algoritma za sortiranje cikli\v cnih pomeraja.

\sirsubsubsection{Leksikografsko pore\dj enje podstringova}

Prva opcija -- direktno, pomo\' cu nizova $C$ dobijenih iz algoritma za sortiranje cikli\v cnih pomeraja.

Druga opcija -- samo preko LCP niza i onog "brzog" algoritma za RMQ.